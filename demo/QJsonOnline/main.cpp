#include "QJsonOnline.h"
#include <QtCore/QCoreApplication>
#include <qtextcodec.h>
#include <qdebug.h>
#include <qdatetime.h>
#include <qfile.h>

#ifdef _WIN32
#pragma execution_character_set("utf-8")
#endif

namespace utils
{
    QByteArray readAll(QFile& f)
    {
        if (f.open(QIODevice::ReadOnly))
        {
            const auto res = f.readAll();
            f.close();
            return res;
        }
        return "";
    }

    inline QByteArray readAll(QFile&& f) { return readAll(f); }

    inline QByteArray readAll(const QString& filename) { return readAll(QFile(filename)); }

    bool writeAll(const QByteArray& str, QFile& f)
    {
        if (f.open(QIODevice::WriteOnly | QIODevice::Truncate))
        {
            const auto len = f.write(str);
            f.close();
            return len == str.length();
        }
        return false;
    }

    inline bool writeAll(const QByteArray& str, QFile&& f) { return writeAll(str, f); }

    inline bool writeAll(const QByteArray& str, const QString& filename) { return writeAll(str, QFile(filename)); }
}

namespace t1
{
    struct KV
    {
        KV() {}

        QString key;

        QJSON_ONLINE(KV, key);
    };

    void main()
    {
        const auto jsonStr = QString(R"({"key":"value"})");
        KV kv;
        kv.fromJson(jsonStr);
        qDebug() << kv.key;
        qDebug() << kv.toJson(QJsonDocument::Indented);
    }
}

namespace t2
{
    struct Arr
    {
        Arr() {}

        QList<int> list;

        QJSON_ONLINE(Arr, list);
    };

    void main()
    {
        const auto jsonStr = QString(R"({"list":[1,2,3,4,5,6,7,8,9,0,345,2,213,456,5,7,423,23,4]})");
        Arr ar;
        ar.fromJson(jsonStr);
        qDebug() << ar.list;
    }
}

namespace t3
{
    struct SResult
    {
        SResult() {}

        QMap<QString, QList<QList<int>>> res;

        QJSON_ONLINE(SResult, res)
    };

    class MyClass
    {
    private:
        int code;
        QString msg;
        SResult res;

    public:
        QJSON_ONLINE(MyClass, code, msg, res)
    };

    /*
    {
    "code": 200,
    "msg": "helloworld",
    "res": {
        "测试1": [
            [1,2,4],
            [2,4,4],
            [3,1,4]
        ],
        "测试随机": [
            [1,2,0],
            [2,4,0],
            [3,1,0]
        ],
        "测试6": [
            [1,2,6],
            [2,4,6],
            [3,1,6]
        ],
        "测试2": [
            [1,2,2],
            [2,4,2],
            [3,1,2]
        ]
    }
    }
    */
    void main()
    {
        MyClass m(utils::readAll("t3.json"));
        qDebug() << m.toJson();
    }
}

namespace t4
{
    struct T
    {
        T() {}
        QJSON_ONLINE(T)
    };

    void main()
    {
        T t;
        qDebug() << t.fromJson(QString(""));    // 1
        qDebug() << t.fromJson(QByteArray("")); // 1
        qDebug() << t.fromJson(QString("[]"));  // 2
        // qDebug() << t.fromJson(QFile(""));      // 3
        qDebug() << t.toJson();                 // { }
        // qDebug() << t.toJson(QFile(""));        // 3
    }
}

namespace t5
{
    // Generated by QJsonOnline
    // https://github.com/Mrliu88888888/QJsonOnline

    class Result
    {
    public:
        Result()
        { }

    private:
        QList<QString> addr;
        QString disp;
        QString end;
        QString start;

    public:
        QJSON_ONLINE(Result, addr, disp, end, start);
    };
    class MyClass
    {
    public:
        MyClass()
            : code(0.0)
        { }

    private:
        double code;
        QString msg;
        Result result;

    public:
        QJSON_ONLINE(MyClass, code, msg, result);
    };

    void main()
    {
        MyClass m(utils::readAll("ip.json"));
        qDebug() << m.toJson();
        qDebug() << utils::writeAll(m.toJson(QJsonDocument::Indented), "ip2.json");
    }
}

namespace t6
{
    // Generated by QJsonOnline
    // https://github.com/Mrliu88888888/QJsonOnline

    struct SResult
    {
        SResult()
        { }

        QString desc;
        QString link;
        QString title;
        QString year;

        QJSON_ONLINE(SResult, desc, link, title, year);
    };
    struct MyStruct
    {
        MyStruct()
            : code(0.0)
        { }

        double code;
        QString msg;
        QList<SResult> result;

        QJSON_ONLINE(MyStruct, code, msg, result);
    };

    void main()
    {
        MyStruct s;
        s.fromJson(utils::readAll("his.json"));
        for (auto& res : s.result) {
            if (res.year == "-565") {
                qDebug() << "find it";
                qDebug() << "modify it";
                res.year = "1998";
                break;
            }
        }
        qDebug() << utils::writeAll(s.toJson(), "his2.json");
    }
}

namespace t7
{
    // Generated by QJsonOnline
// https://github.com/Mrliu88888888/QJsonOnline

    struct Info
    {
        Info()
            : index(0.0)
        { }

        QString hot;
        QString href;
        double index;
        QString title;

        QJSON_ONLINE(Info, hot, href, index, title);
    };
    struct SResult
    {
        SResult()
        { }

        QMap<QString, QList<Info>> info;

        QJSON_ONLINE(SResult, info);
    };
    struct MyStruct
    {
        MyStruct()
            : code(0.0)
        { }

        double code;
        QString msg;
        SResult result;

        QJSON_ONLINE(MyStruct, code, msg, result);
    };

    void main()
    {
        MyStruct m(utils::readAll("hot.json"));
        qDebug() << utils::writeAll(m.toJson(QJsonDocument::Indented), "hot2.json");
    }
}

namespace t8
{
    // Generated by QJsonOnline
// https://github.com/Mrliu88888888/QJsonOnline

    class MedalsList
    {
    public:
        MedalsList()
        { }

        inline const QString& getCountryid() const { return countryid; }
        inline QString& getGold() { return gold; }

    private:
        QString bronze;
        QString count;
        QString countryid;
        QString countryname;
        QString gold;
        QString rank;
        QString silver;

    public:
        QJSON_ONLINE(MedalsList, bronze, count, countryid, countryname, gold, rank, silver);
    };
    class Result
    {
    public:
        Result()
            : total(0.0)
        { }

    public:
        inline QList<MedalsList>& getMedalsList() { return medalsList; }

    private:
        QList<MedalsList> medalsList;
        double total;

    public:
        QJSON_ONLINE(Result, medalsList, total);
    };
    class MyClass
    {
    public:
        MyClass()
            : code(0.0)
        { }

    public:
        inline Result& getResult() { return result; }

    private:
        double code;
        QString msg;
        Result result;

    public:
        QJSON_ONLINE(MyClass, code, msg, result);
    };

    void main()
    {
        MyClass m;
        m.fromJson(utils::readAll("ol.json"));
        for (auto& res : m.getResult().getMedalsList())
        {
            if (res.getCountryid() == "CHN") {
                res.getGold() = "99";
            }
        }
        utils::writeAll(m.toJson(), "ol2.json");
    }
}

namespace t9
{
    // Generated by QJsonOnline
// https://github.com/Mrliu88888888/QJsonOnline

    struct SResult
    {
        SResult()
        { }

        QString date;
        QString mov_area;
        QString mov_director;
        QString mov_intro;
        QString mov_link;
        QString mov_pic;
        QString mov_rating;
        QString mov_text;
        QString mov_title;
        QList<QString> mov_type;
        QString mov_year;
        QString poster_url;

        void print()
        {
            qDebug() << date;
            qDebug() << mov_area;
            qDebug() << mov_director;
            qDebug() << mov_intro;
            qDebug() << mov_link;
            qDebug() << mov_pic;
            qDebug() << mov_rating;
            qDebug() << mov_text;
            qDebug() << mov_title;
            qDebug() << mov_type;
            qDebug() << mov_year;
            qDebug() << poster_url;
        }

        QJSON_ONLINE(SResult, date, mov_area, mov_director, mov_intro, mov_link, mov_pic, mov_rating, mov_text, mov_title, mov_type, mov_year, poster_url);
    };
    struct Mov
    {
        Mov()
            : code(0.0)
        { }

        double code;
        QString msg;
        SResult result;

        void print()
        {
            qDebug() << "code: " << code;
            qDebug() << "msg: " << msg;
            result.print();
            qDebug() << "========================================";
        }

        QJSON_ONLINE(Mov, code, msg, result);
    };

    void main()
    {
        Mov m(utils::readAll("mov.json"));
        m.print();
    }
}

namespace t10
{
    struct SData
    {
        SData() {}

        QString k;

        QJSON_ONLINE(SData, k);
    };

    struct SVe
    {
        QVector<QVector<QVector<QVector<QVector<QVector<QVector<QVector<QVector<SData>>>>>>>>> v;

        QJSON_ONLINE(SVe, v);
    };

    void main()
    {
        SVe v(QString(R"({"v":[[[[[[[[[{"k":"1"}]]]]]]]]]})"));
        utils::writeAll(v.toJson(), "t10.json");
    }
}

namespace t11
{
    class Obj
    {
    public:
        Obj() = default;

        QString _1;
        QString n;
        QString _22;
        QString __;

        QJSON_ONLINE(Obj, _1, n, _22, __)
    };

    void main()
    {
        const auto cstr =
            R"({
                "1": "hello",
                "n": "123",
                "22": "456",
                "_": "++"
                })";

        Obj o;
        o.fromJson(QByteArray(cstr));
        qDebug() << utils::writeAll(o.toJson(QJsonDocument::Indented), "t11.json");
    }
}

#pragma region Log
QFile* gFileLog = NULL;

const char* const msgHead[] = {
    "Debug   ",
    "Warning ",
    "Critical",
    "Fatal   ",
    "Info    "
};

void myMessageOutput(QtMsgType type, const QMessageLogContext& context, const QString& msg)
{
    QByteArray localMsg = msg.toLocal8Bit();
    QString current_date_time = "";  //  QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss ddd");

    if (gFileLog) {
        QTextStream tWrite(gFileLog);

        QString msgText = "%1 | %6 | %2:%3, %4 | %5\n";
        msgText = msgText.arg(msgHead[type]).arg(context.file).arg(context.line).arg(context.function).arg(localMsg.constData()).arg(current_date_time);
        //gFileLog->write(msgText.toLocal8Bit(), msgText.length());
        tWrite << msgText;
    }
    else {
        fprintf(stderr, "%s | %s | %s:%u, %s | %s\n", msgHead[type], current_date_time.toLocal8Bit().constData(), context.file, context.line, context.function, localMsg.constData());
    }
}

void logSysInit(QString filePath)
{
    gFileLog = new QFile(filePath);
    if (!gFileLog->open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate)) {
        return;
    }
    //初始化自定义日志处理函数myMessageOutput
    qInstallMessageHandler(myMessageOutput);
}
#pragma endregion

int main(int argc, char* argv[])
{
    QCoreApplication a(argc, argv);
    QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF-8"));
#ifdef _WIN32
    system("chcp 65001");
#endif

    logSysInit("my.log");

    t1::main();
    t2::main();
    t3::main();
    t4::main(); // 错误测试
    t5::main();
    t6::main();
    t7::main();
    t8::main();
    t9::main();
    t10::main();
    t11::main();

    return 0;
}
